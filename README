gilly_sraia, ronnierozanski
207430794, 322293796

Answer:
We designed the trees package with a modular approach. We have five distinct classes: 
Flora, Tree, TreeTrunk, Leaf, and Fruit.
 Each class is responsible for a specific aspect of tree creation and behavior in the game.

A review about the different classes in the Trees package:
1. Flora Class:
Flora acts as the main coordinator for generating all the trees in the game.
It handles the logic for determining whether a tree should be generated at a 
given X-coordinate based on random probabilities.
The generated tree components (Tree returns a List of tree parts) are added to the game
world in range, using the addFunc provided during initialization, ensuring smooth integration 
with the game's environment.
2. Tree Class:
The Tree class constructs a single tree by generating its trunk, leaves, and fruits, 
each handled by separate classes.
 It determines the trunk height (=number of TreeTrunk objects) and leaf layout, 
ensuring a visually cohesive and organized structure.
The class uses TreeTrunk, Leaf, and Fruit objects to assemble a complete tree, creating an 
appealing and dynamic visual.
This class interacts with TreeTrunk, Leaf, and Fruit to build a complete and 
visually appealing tree.
3. TreeTrunk Class:
TreeTrunk represents the vertical structure of the tree and extends the Block class.
Each trunk block has a distinct brownish color to differentiate it from terrain blocks. 
The full trunk is assembled in the Tree class.
4. Leaf Class:
The Leaf class handles the creation of individual leaves and their dynamic animations, 
such as rotation and scaling, to simulate natural movement. 
Leaves form a dense canopy above the trunk, contributing to the tree's visual appeal.
5. Fruit Class:
The Fruit class manages the generation of fruits and their interaction with the avatar.
Upon collection, fruits disappear, provide energy to the avatar, and regenerate after a 
predefined time (DAY_CYCLE_LENGTH).
Fruits are randomly positioned on leaves, adding an interactive element to the gameplay.

This design promotes code organization, adheres to the Open-Closed Principle, 
and ensures encapsulation, with each class focusing on its unique role within the 
trees package.

Adittional classes we added:
We used Observer design pattern to enable communication between the Avatar and the Cloud.
The AvatarJumpListener interface we added is designed to enable communication between the 
Avatar and othergame objects (in our case: clouds), that need to respond to the avatar's jump. 
The interface defines a single method, jumpMode(), which provides a callback mechanism for 
triggering specific behaviors when the avatar jumps.

The Cloud class is responsible for creating the cloud, managing its movement across the screen, 
and generating rain when the avatar jumps. 
The generated cloud is constructed with Block objects.
The createRain() method generates raindrops from cloud blocks. These raindrops fall under the 
influence of gravity and fade out as they move.
The jumpMode() method, triggered by the AvatarJumpListener, initiates rain generation, 
creating an immersive interaction between 
the avatar and the environment.
The class acts as an observer to the Avatarâ€™s jumps, utilizing the Observer design pattern. 
This ensures that the cloud system reacts dynamically to the avatar's actions.

In summary, we focused in our design on principles like encapsulation, modularity, 
and extensibility to build a maintainable 
and flexible system. Each class has a clear role, minimizing dependencies. The Avatar class uses 
the Observer pattern via AvatarJumpListener to decouple event handling, 
such as triggering rain from the cloud. We also prioritized composition over inheritance, 
passing functions to enhance flexibility.

